(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{567:function(t,e,l){"use strict";l.r(e);var s=l(17),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,l=t._self._c||e;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h2",{attrs:{id:"获取元素css值之getcomputedstyle方法熟悉"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#获取元素css值之getcomputedstyle方法熟悉"}},[t._v("#")]),t._v(" 获取元素CSS值之getComputedStyle方法熟悉.")]),t._v(" "),l("h3",{attrs:{id:"一-定义"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#一-定义"}},[t._v("#")]),t._v(" (一) 定义:"),l("br")]),t._v(" "),l("p",[t._v('getComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值。返回的是一个CSS样式声明对象([object CSSStyleDeclaration])，只读。\n语法如下:\nvar style = window.getComputedStyle("元素", "伪类");\n第二个参数“伪类”是必需的（如果不是伪类，设置为null），不过现在嘛，不是必需参数了。')]),t._v(" "),l("h3",{attrs:{id:"二-getcomputedstyle与style的区别"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#二-getcomputedstyle与style的区别"}},[t._v("#")]),t._v(" (二)getComputedStyle与style的区别")]),t._v(" "),l("ul",[l("li",[l("p",[t._v("只读与可写:"),l("br"),t._v("\n正如上面提到的getComputedStyle方法是只读的，只能获取样式，不能设置；而element.style能读能写，能屈能伸。")])]),t._v(" "),l("li",[l("p",[t._v("获取的对象范围:"),l("br"),t._v("\ngetComputedStyle方法获取的是最终应用在元素上的所有CSS属性对象（即使没有CSS代码，也会把默认的祖宗八代都显示出来）；\n而element.style只能获取元素style属性中的CSS样式。因此对于一个光秃秃的元素")]),l("p",[t._v("，\ngetComputedStyle方法返回对象中length属性值（如果有）就是190+(据我测试FF:192, IE9:195, Chrome:253, 不同环境结果可能有差异), 而element.style就是0。")])])]),t._v(" "),l("h3",{attrs:{id:"三-getcomputedstyle与currentstyle"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#三-getcomputedstyle与currentstyle"}},[t._v("#")]),t._v(" (三)getComputedStyle与currentStyle")]),t._v(" "),l("p",[t._v("currentStyle是IE浏览器自娱自乐的一个属性，其与element.style可以说是近亲，至少在使用形式上类似，\nelement.currentStyle，差别在于element.currentStyle返回的是元素当前应用的最终CSS属性值（包括外链CSS文件，页面中嵌入的")]),l("style")])}),[],!1,null,null,null);e.default=r.exports}}]);